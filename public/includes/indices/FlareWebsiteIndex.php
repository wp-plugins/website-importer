<?php
/**
 * Created by PhpStorm.
 * User: patrick
 * Date: 14-06-29
 * Time: 12:56 PM
 */

namespace html_import\indices;

use droppedbars\datastructure\LinkedTree;

require_once( dirname( __FILE__ ) . '/WebsiteIndex.php' );
require_once( dirname( __FILE__ ) . '/../retriever/FileRetriever.php' );
require_once( dirname( __FILE__ ) . '/WebPage.php' );

/**
 * Class FlareWebsiteIndex
 * Provides the ability to retrieve each HTML file defined in a MadCap Flare export of a website.
 * After creating the FlareWebsiteIndex object with a reference to the source location, call @function buildHierarchyFromWebsiteIndex to build up a listing of all the HTML files in the Flare export.  Calling @function getNextHTMLFile will return a LinkedTree object that contains references to the HTML file.
 * @package html_import\indices
 */
class FlareWebsiteIndex extends WebsiteIndex {

	/**
	 * Builds the file hierarchy from the index files generated by a MadCap Flare export.  It will search the source location for Toc.js, which defines the file hierarchy, and Toc_Chunk0.js for the file title and location.
	 *
	 * TODO: Note, limitations: the index files are named Toc.js and [Toc_chunk]0.js.  If the Toc.js defines a different chunk name, it will not work.  Also, it is limited only to a single chunk, so [Toc_chunk]0.js.
	 *
	 * @param null|string $indexFile
	 *
	 * @return null|void
	 */
	public function buildHierarchyFromWebsiteIndex( $indexFile = null ) {
		$indexFileToUse = 'Toc.js';

		$tocJS = $this->retriever->findFile( $indexFileToUse ); // this file defines the hierarchy

		$tocContents = $this->retriever->retrieveFileContents( $tocJS );

		preg_match( '/numchunks:([0-9]*?),/', $tocContents, $numChunksMatch );
		if ( sizeof( $numChunksMatch ) > 1 ) { // assumes that no tocChunks means empty or invalid file
			$numChunks = $numChunksMatch[1]; // TODO: deal with multiple chunks
			preg_match( "/prefix:'(.*?)',/", $tocContents, $tocMatches );
			$chunkName = $tocMatches[1];
			if ( sizeof( $tocMatches ) > 1 ) {  // assumes no chunk file names could be found
				preg_match( '/^define\((.*)\);$/', $tocContents, $matches );
				$returnValue = preg_replace( '/(\\w*):/U', '"$1":', $matches[1], - 1, $count );
				$jsonString  = str_replace( "'", "\"", $returnValue );
				$jsonArray   = json_decode( $jsonString, true );

				// TODO: deal with multiple chunk files
				$fullChunkFileName = $chunkName . '0.js';
				$chunkFile         = $this->retriever->findFile( $fullChunkFileName ); // this file defines what each file's details are
				$chunkContents     = $this->retriever->retrieveFileContents( $chunkFile );
				if ( !is_null( $chunkContents ) ) {
					$fileTree = $this->getFlareFileList( $chunkContents );
					if ( sizeof( $fileTree ) > 0 ) {
						$fileOrder = $jsonArray['tree']['n'];

						$this->buildTree( $fileOrder, $fileTree, null );
					} else {
						echo 'The TOC Chunk file ' . $fullChunkFileName . ' has no valid definitions inside.<br>';
					}
				} else {
					echo 'Unable to find the TOC Chunk file ' . $fullChunkFileName . ' or file was empty.<br>';
				}
			} else {
				echo 'Unable to find TOC Chunk files defined in ' . $indexFileToUse . '.<br>';
			}
		} else {
			echo $indexFileToUse . ' was either empty of data, invalid, or not present.<br>';
		}
	}

	/**
	 * Converts the contents of a Toc_Chunk file into an array
	 * The file using the values:
	 *  path
	 *  i - id
	 *  t - title
	 *
	 * @param string $tocChunkContents
	 *
	 * @return array
	 */
	private function getFlareFileList( $tocChunkContents ) {
		$count   = null;
		$matches = null;
		preg_match( '/^define\((.*)\);$/', $tocChunkContents, $matches );

		$returnValue = preg_replace( '/(\\w):([\{\[])/', '"$1":$2', $matches[1], - 1, $count );

		$jsonString = str_replace( "'", "\"", $returnValue );

		$jsonArray = json_decode( $jsonString, true );

		$fileList = Array();
		foreach ( $jsonArray as $path => $chunk ) {
			$id    = $chunk['i'];
			$title = $chunk['t'];
			if ( sizeof( $id ) > 1 ) {
				foreach ( $id as $key => $value ) {
					$fileList[$value]['path']  = null;
					$fileList[$value]['title'] = $title[$key];
				}
			} else {
				$fileList[$id[0]]['path']  = $path;
				$fileList[$id[0]]['title'] = $title[0];
			}
		}

		return $fileList;
	}

	/**
	 * Build a LinkedTree tree from the file ordering and the file listing derived from the Flare index files.
	 * The HTML file information is stored in the payload of the LinkedTree with WebPage object representing the file.
	 *
	 * @param Array       $fileOrder  array based on Toc.js
	 * @param Array       $fileList   array based on Toc_Chunk0.js
	 * @param  LinkedTree $parentNode the base node to attach the hierarchy to
	 *
	 * @return LinkedTree|null
	 */
	private function buildTree( Array $fileOrder, Array $fileList, LinkedTree $parentNode = null ) {
		$firstNode = null;
		$counter   = 0;
		foreach ( $fileOrder as $item ) {
			$itemIndex = $item['i'];
			$pagePath  = $fileList[$itemIndex]['path'];
			$pageTitle = $fileList[$itemIndex]['title'];

			$node = new WebPage( $this->retriever, $pageTitle, $pagePath );
			$node->setOrderPosition( $itemIndex );
			if ( !is_null( $parentNode ) ) {
				$parentNode->addChild( $node );
			} else {
				$this->trees[] = $node;
			}
			if ( $counter == 0 ) {
				$firstNode = $node;
			}
			if ( array_key_exists( 'n', $item ) ) {
				$itemChildren = $item['n'];
				$this->buildTree( $itemChildren, $fileList, $node );
			}
			$counter ++;
		}

		return $firstNode;
	}

}